# 后端开发规范

> **版本**: v1.0
> **更新时间**: 2025年10月1日
> **适用范围**: 支付积分系统后端开发

---

## 📋 目录

1. [代码规范](#代码规范)
2. [数据库规范](#数据库规范)
3. [API设计规范](#api设计规范)
4. [安全规范](#安全规范)
5. [错误处理规范](#错误处理规范)
6. [日志规范](#日志规范)
7. [测试规范](#测试规范)

---

## 代码规范

### 1. 命名规范

#### 1.1 文件命名

- **路由文件**: 小写复数，如 `users.js`, `merchants.js`
- **工具文件**: 小写驼峰，如 `logger.js`, `jwt.js`
- **中间件**: 小写驼峰，如 `validation.js`, `rateLimiter.js`

```javascript
✅ routes/users.js
✅ utils/logger.js
✅ middlewares/validation.js

❌ routes/User.js
❌ utils/Logger.js
```

#### 1.2 变量命名

- **普通变量**: 小写驼峰 `userName`, `totalAmount`
- **常量**: 大写下划线 `MAX_RETRY`, `API_VERSION`
- **类名**: 大写驼峰 `ApiError`, `UserService`
- **私有变量**: 下划线开头 `_privateVar`

```javascript
✅ const userName = 'admin';
✅ const MAX_CONNECTIONS = 10;
✅ class ApiError extends Error {}

❌ const UserName = 'admin';
❌ const maxConnections = 10;
```

#### 1.3 函数命名

- **动词开头**: `getUser`, `createOrder`, `validateInput`
- **布尔函数**: `is/has/can` 开头，如 `isValid`, `hasPermission`
- **异步函数**: 明确返回Promise

```javascript
✅ async function getUser(id) { }
✅ function isAdmin(user) { }
✅ function hasPermission(user, action) { }

❌ async function user(id) { }
❌ function admin(user) { }
```

### 2. 代码组织

#### 2.1 文件结构

每个文件应按以下顺序组织:

```javascript
// 1. 依赖导入
const express = require('express');
const { validateInput } = require('../middlewares/validation');

// 2. 常量定义
const MAX_PAGE_SIZE = 100;
const DEFAULT_PAGE_SIZE = 20;

// 3. 工具函数
function calculatePoints(amount) {
  return Math.floor(amount / 100);
}

// 4. 主要逻辑
router.get('/', async (req, res) => {
  // ...
});

// 5. 导出
module.exports = router;
```

#### 2.2 函数长度

- **单个函数**: 不超过50行
- **复杂逻辑**: 拆分成多个小函数
- **注释**: 复杂逻辑必须添加注释

```javascript
✅ 好的示例
async function processPayment(orderId) {
  const order = await getOrder(orderId);
  await validateOrder(order);
  const payment = await createPayment(order);
  await updatePoints(order.userId, order.points);
  return payment;
}

❌ 避免超长函数
async function processPayment(orderId) {
  // 100行代码...
}
```

### 3. 异步处理

#### 3.1 使用async/await

```javascript
✅ 推荐
async function getUser(id) {
  try {
    const [users] = await pool.execute('SELECT * FROM users WHERE id = ?', [id]);
    return users[0];
  } catch (error) {
    logger.error('Failed to get user', { id, error });
    throw error;
  }
}

❌ 避免回调地狱
function getUser(id, callback) {
  pool.execute('SELECT * FROM users WHERE id = ?', [id], (err, users) => {
    if (err) return callback(err);
    callback(null, users[0]);
  });
}
```

#### 3.2 错误处理

所有async函数必须有错误处理:

```javascript
✅ 路由层错误处理
router.get('/:id', async (req, res, next) => {
  try {
    const user = await getUser(req.params.id);
    res.json({ success: true, data: user });
  } catch (error) {
    next(error);  // 传递给错误处理中间件
  }
});

✅ 服务层错误处理
async function createOrder(data) {
  try {
    return await pool.execute('INSERT INTO orders ...', [data]);
  } catch (error) {
    logger.error('Create order failed', { data, error });
    throw new ApiError(500, 'Failed to create order');
  }
}
```

---

## 数据库规范

### 1. SQL查询规范

#### 1.1 必须使用参数化查询

```javascript
✅ 安全：参数化查询
const [users] = await pool.execute(
  'SELECT * FROM users WHERE id = ? AND status = ?',
  [userId, status]
);

❌ 危险：字符串拼接
const [users] = await pool.query(
  `SELECT * FROM users WHERE id = ${userId}` // SQL注入风险！
);
```

#### 1.2 避免SELECT *

```javascript
✅ 明确指定字段
const [users] = await pool.execute(
  'SELECT id, nickname, avatar, created_at FROM users WHERE id = ?',
  [userId]
);

❌ 避免查询所有字段
const [users] = await pool.execute('SELECT * FROM users WHERE id = ?', [userId]);
```

#### 1.3 使用JOIN优化N+1查询

```javascript
✅ 一次JOIN查询
const [orders] = await pool.query(`
  SELECT
    o.*,
    u.nickname as userName,
    m.merchant_name as merchantName
  FROM payment_orders o
  LEFT JOIN users u ON o.user_id = u.id
  LEFT JOIN merchants m ON o.merchant_id = m.id
  WHERE o.status = ?
`, [status]);

❌ N+1查询
const [orders] = await pool.query('SELECT * FROM payment_orders WHERE status = ?', [status]);
for (const order of orders) {
  order.user = await getUser(order.user_id);  // N次额外查询
  order.merchant = await getMerchant(order.merchant_id);  // N次额外查询
}
```

### 2. 事务处理

#### 2.1 使用事务确保数据一致性

```javascript
✅ 正确的事务处理
async function processPayment(orderId) {
  const connection = await pool.getConnection();

  try {
    await connection.beginTransaction();

    // 1. 更新订单状态
    await connection.execute(
      'UPDATE payment_orders SET status = "paid" WHERE id = ?',
      [orderId]
    );

    // 2. 创建积分记录
    await connection.execute(
      'INSERT INTO points_records (id, user_id, points_change) VALUES (?, ?, ?)',
      [recordId, userId, points]
    );

    // 3. 更新用户积分
    await connection.execute(
      'UPDATE user_points SET available_points = available_points + ? WHERE user_id = ?',
      [points, userId]
    );

    await connection.commit();
    return { success: true };
  } catch (error) {
    await connection.rollback();
    throw error;
  } finally {
    connection.release();
  }
}
```

### 3. 索引规范

#### 3.1 常用查询字段添加索引

```sql
-- ✅ 单列索引
CREATE INDEX idx_user_id ON payment_orders(user_id);
CREATE INDEX idx_created_at ON payment_orders(created_at);

-- ✅ 复合索引（根据查询条件）
CREATE INDEX idx_user_status_created ON payment_orders(user_id, status, created_at);

-- ✅ 唯一索引
CREATE UNIQUE INDEX idx_merchant_no ON merchants(merchant_no);
```

#### 3.2 索引使用原则

- WHERE条件字段加索引
- JOIN关联字段加索引
- ORDER BY排序字段加索引
- 高频查询复合索引
- 避免过多索引（影响写入性能）

---

## API设计规范

### 1. RESTful规范

#### 1.1 URL设计

```javascript
✅ 符合RESTful
GET    /api/v1/users              # 获取用户列表
GET    /api/v1/users/:id          # 获取单个用户
POST   /api/v1/users              # 创建用户
PUT    /api/v1/users/:id          # 更新用户
DELETE /api/v1/users/:id          # 删除用户

❌ 不符合RESTful
GET    /api/v1/getUserList
POST   /api/v1/createUser
POST   /api/v1/updateUser/:id
```

#### 1.2 HTTP状态码

```javascript
200 OK                  # 成功
201 Created             # 创建成功
400 Bad Request         # 请求参数错误
401 Unauthorized        # 未认证
403 Forbidden           # 无权限
404 Not Found           # 资源不存在
409 Conflict            # 资源冲突
429 Too Many Requests   # 请求过多
500 Internal Server Error  # 服务器错误
503 Service Unavailable   # 服务不可用
```

### 2. 请求/响应格式

#### 2.1 统一响应格式

```javascript
✅ 成功响应
{
  "success": true,
  "data": {
    "id": "user_001",
    "nickname": "张三"
  },
  "message": "操作成功"  // 可选
}

✅ 失败响应
{
  "success": false,
  "message": "用户不存在",
  "errorCode": "USER_NOT_FOUND",  // 可选
  "errors": [...]  // 验证错误详情（可选）
}

✅ 分页响应
{
  "success": true,
  "data": [...],
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "total": 100
  }
}
```

#### 2.2 参数命名规范

```javascript
✅ API使用驼峰命名
{
  "userId": "user_001",
  "merchantId": "merchant_001",
  "createdAt": "2025-10-01T10:00:00Z"
}

❌ 避免下划线命名（数据库用）
{
  "user_id": "user_001",
  "merchant_id": "merchant_001",
  "created_at": "2025-10-01T10:00:00Z"
}
```

### 3. 分页规范

```javascript
// ✅ 统一的分页参数
router.get('/', async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const pageSize = Math.min(parseInt(req.query.pageSize) || 20, 100);  // 限制最大100
  const offset = (page - 1) * pageSize;

  const [data] = await pool.query('SELECT * FROM users LIMIT ? OFFSET ?', [pageSize, offset]);
  const [total] = await pool.query('SELECT COUNT(*) as count FROM users');

  res.json({
    success: true,
    data,
    pagination: {
      page,
      pageSize,
      total: total[0].count
    }
  });
});
```

---

## 安全规范

### 1. 认证授权

#### 1.1 所有API必须认证

```javascript
✅ 需要认证的路由
app.use('/api/v1/admin', authenticateToken, requireAdmin);
app.use('/api/v1/users', authenticateToken);

// 认证中间件
function authenticateToken(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) {
    return res.status(401).json({ success: false, message: '未认证' });
  }

  try {
    req.user = jwt.verify(token, process.env.JWT_SECRET);
    next();
  } catch (error) {
    return res.status(403).json({ success: false, message: 'Token无效' });
  }
}
```

### 2. 输入验证

#### 2.1 所有输入必须验证

```javascript
✅ 使用express-validator
const { body, validationResult } = require('express-validator');

router.post('/create',
  // 验证规则
  body('amount').isInt({ min: 1 }).withMessage('金额必须大于0'),
  body('merchantId').notEmpty().withMessage('商户ID不能为空'),
  body('description').optional().isLength({ max: 200 }),

  // 处理函数
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: '参数验证失败',
        errors: errors.array()
      });
    }

    // 业务逻辑...
  }
);
```

### 3. 敏感信息保护

#### 3.1 密码加密

```javascript
✅ 使用bcrypt加密密码
const bcrypt = require('bcryptjs');

// 注册时加密
const passwordHash = await bcrypt.hash(password, 10);
await saveUser({ username, passwordHash });

// 登录时验证
const isValid = await bcrypt.compare(password, user.password_hash);
```

#### 3.2 环境变量

```javascript
✅ 敏感配置使用环境变量
const config = {
  jwtSecret: process.env.JWT_SECRET,
  dbPassword: process.env.DB_PASSWORD,
  wechatApiKey: process.env.WECHAT_API_KEY
};

❌ 避免硬编码
const config = {
  jwtSecret: 'my_secret_key',  // 危险！
  dbPassword: '123456',         // 危险！
};
```

### 4. 限流保护

```javascript
✅ 添加限流中间件
const rateLimit = require('express-rate-limit');

// API限流
const apiLimiter = rateLimit({
  windowMs: 60000,  // 1分钟
  max: 100          // 最多100次请求
});

// 登录限流
const loginLimiter = rateLimit({
  windowMs: 60000,
  max: 5,           // 最多5次登录尝试
  skipSuccessfulRequests: true
});

app.use('/api', apiLimiter);
app.use('/api/v1/auth/login', loginLimiter);
```

---

## 错误处理规范

### 1. 自定义错误类

```javascript
// ✅ 定义ApiError类
class ApiError extends Error {
  constructor(statusCode, message, errorCode = null) {
    super(message);
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    this.name = 'ApiError';
  }
}

// 使用
throw new ApiError(404, '用户不存在', 'USER_NOT_FOUND');
throw new ApiError(403, '无权限访问', 'PERMISSION_DENIED');
```

### 2. 统一错误处理中间件

```javascript
// ✅ 全局错误处理
app.use((err, req, res, next) => {
  logger.error('Error occurred', {
    error: err.message,
    stack: err.stack,
    path: req.path
  });

  if (err instanceof ApiError) {
    return res.status(err.statusCode).json({
      success: false,
      message: err.message,
      errorCode: err.errorCode
    });
  }

  res.status(500).json({
    success: false,
    message: '服务器内部错误'
  });
});
```

### 3. 错误码规范

```javascript
// 定义错误码常量
const ERROR_CODES = {
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  INVALID_TOKEN: 'INVALID_TOKEN',
  PERMISSION_DENIED: 'PERMISSION_DENIED',
  DUPLICATE_ENTRY: 'DUPLICATE_ENTRY',
  INSUFFICIENT_BALANCE: 'INSUFFICIENT_BALANCE'
};

// 使用
throw new ApiError(400, '积分余额不足', ERROR_CODES.INSUFFICIENT_BALANCE);
```

---

## 日志规范

### 1. 日志级别

```javascript
logger.error('严重错误，需立即处理');
logger.warn('警告信息，需要关注');
logger.info('一般信息，记录操作');
logger.http('HTTP请求日志');
logger.debug('调试信息，仅开发环境');
```

### 2. 日志内容规范

```javascript
✅ 好的日志
logger.info('User login', {
  userId: 'user_001',
  ip: '192.168.1.1',
  timestamp: new Date().toISOString()
});

logger.error('Payment failed', {
  orderId: 'order_123',
  amount: 100,
  error: error.message,
  stack: error.stack
});

❌ 不好的日志
logger.info('用户登录了');  // 缺少关键信息
logger.error(error);        // 只记录错误对象
```

### 3. 业务日志

```javascript
✅ 记录关键业务操作
function logOperation(operation, userId, details = {}) {
  logger.info(`Operation: ${operation}`, {
    userId,
    ...details,
    timestamp: new Date().toISOString()
  });
}

// 使用
logOperation('Create Order', userId, { orderId, amount });
logOperation('Refund', userId, { orderId, reason });
```

---

## 测试规范

### 1. 单元测试

```javascript
// tests/utils/jwt.test.js
const { generateToken, verifyToken } = require('../utils/jwt');

describe('JWT Utils', () => {
  test('should generate valid token', () => {
    const user = { id: 'user_001', type: 'user' };
    const token = generateToken(user);
    expect(token).toBeDefined();
    expect(typeof token).toBe('string');
  });

  test('should verify valid token', () => {
    const user = { id: 'user_001', type: 'user' };
    const token = generateToken(user);
    const decoded = verifyToken(token);
    expect(decoded.id).toBe('user_001');
  });
});
```

### 2. 集成测试

```javascript
// tests/routes/auth.test.js
const request = require('supertest');
const app = require('../server');

describe('POST /api/v1/auth/admin/login', () => {
  test('should return token on valid credentials', async () => {
    const res = await request(app)
      .post('/api/v1/auth/admin/login')
      .send({ username: 'admin', password: 'admin123' });

    expect(res.status).toBe(200);
    expect(res.body.success).toBe(true);
    expect(res.body.data.token).toBeDefined();
  });

  test('should return 401 on invalid credentials', async () => {
    const res = await request(app)
      .post('/api/v1/auth/admin/login')
      .send({ username: 'admin', password: 'wrong' });

    expect(res.status).toBe(401);
    expect(res.body.success).toBe(false);
  });
});
```

### 3. 测试覆盖率要求

- **核心业务逻辑**: 80%以上
- **API路由**: 70%以上
- **工具函数**: 90%以上

---

## 总结

### 核心原则

1. **安全第一**: 防SQL注入、XSS、CSRF等
2. **性能优先**: 避免N+1查询、使用缓存
3. **代码清晰**: 命名规范、注释完整
4. **错误处理**: 统一处理、详细日志
5. **可测试性**: 单元测试、集成测试

### 检查清单

开发完成后，请检查:

- [ ] 所有SQL使用参数化查询
- [ ] API都有认证和权限验证
- [ ] 输入参数都经过验证
- [ ] 敏感信息使用环境变量
- [ ] 关键操作记录日志
- [ ] 错误有统一处理
- [ ] 添加了必要的注释
- [ ] 编写了测试用例
- [ ] 代码通过了lint检查
- [ ] 性能测试通过

---

**严格遵守规范，保证代码质量！** 📝
