# 03-支付积分同步流程设计

## 📖 文档信息
- **文档版本**：V1.0
- **创建日期**：2024年9月
- **系统架构师**：[姓名]
- **业务分析师**：[姓名]
- **评审状态**：待评审

---

## 🎯 流程概述

本文档详细设计用户通过商户微信支付二维码支付后，系统自动发放1:1积分的完整技术流程，确保支付成功与积分发放的强一致性。

**重要前提：商户必须完成微信支付特约商户申请并获得有效的`sub_mch_id`才能生成收款二维码。**

### 核心需求
- **支付方式**：用户扫描商户微信支付二维码
- **商户要求**：商户信息必须与微信支付字段完全匹配，拥有有效特约商户号
- **积分规则**：支付成功后立即获得1:1积分（1元=1积分）
- **积分归属**：积分完全属于平台方，不属于任何商户
- **同步要求**：支付成功与积分发放必须同步完成
- **用户体验**：流程简单，反馈及时

---

## 🔄 完整业务流程设计

### 整体流程架构
```
用户扫码 → 跳转支付页 → 确认支付 → 微信支付 → 支付成功 → 积分发放 → 完成提示
    ↓         ↓          ↓         ↓         ↓         ↓         ↓
商户识别   用户登录    订单创建   第三方处理  回调处理   积分入账   状态同步
```

### 详细步骤设计

#### 步骤1：用户扫码识别
```typescript
// 二维码内容设计
interface QRCodeData {
  type: 'merchant_payment',           // 二维码类型
  merchantId: string,                 // 商户ID
  amount?: number,                    // 固定金额（可选）
  description?: string,               // 商品描述
  qrCodeId: string,                  // 二维码唯一ID
  timestamp: number,                  // 生成时间戳
  signature: string                   // 签名验证
}

// 二维码生成示例
const qrCodeContent = {
  type: 'merchant_payment',
  merchantId: 'MERCHANT_12345',
  qrCodeId: 'QR_67890',
  timestamp: 1640995200000,
  signature: 'abc123...'
}
```

**技术实现**：
- 用户通过小程序扫码功能识别二维码
- 解析二维码内容，验证签名和有效性
- 获取商户信息和支付参数

#### 步骤2：跳转支付页面
```typescript
// 支付页面数据结构
interface PaymentPageData {
  // 商户信息
  merchant: {
    id: string,
    name: string,              // 商户名称
    avatar: string,            // 商户头像
    businessStatus: 'open' | 'closed', // 营业状态
    description?: string       // 商户描述
  },
  
  // 用户信息
  user: {
    id: string,
    nickname: string,
    avatar: string,
    currentPoints: number,     // 当前积分余额
    memberLevel?: string       // 会员等级
  },
  
  // 支付信息
  payment: {
    amount?: number,           // 支付金额（固定金额时显示）
    expectedPoints: number,    // 预计获得积分
    pointsValue: string,       // 积分价值说明
    paymentMethods: string[]   // 支持的支付方式
  }
}
```

**页面设计要求**：
```
支付页面布局：
├── 商户信息区域
│   ├── 商户名称和头像
│   ├── 营业状态标识
│   └── 商户认证标识
├── 用户信息区域
│   ├── 用户头像和昵称
│   ├── 当前积分余额
│   └── 会员等级（如有）
├── 支付金额区域
│   ├── 金额输入框（自定义金额）
│   ├── 常用金额快捷选择
│   └── 积分奖励预览
├── 积分说明区域
│   ├── "支付即获得等额积分"
│   ├── "1元=1积分"
│   └── 积分使用说明链接
└── 支付按钮区域
    ├── "确认支付"按钮
    └── 支付方式选择
```

#### 步骤3：用户确认支付
```typescript
// 支付确认逻辑
interface PaymentConfirmation {
  // 验证项目
  validations: {
    userAuth: boolean,         // 用户登录状态
    merchantValid: boolean,    // 商户有效性
    amountValid: boolean,      // 金额有效性
    pointsCalculation: boolean // 积分计算正确性
  },
  
  // 确认信息
  confirmInfo: {
    finalAmount: number,       // 最终支付金额
    pointsToAward: number,     // 将获得积分
    paymentMethod: string,     // 支付方式
    orderDescription: string   // 订单描述
  }
}
```

**确认页面逻辑**：
- 显示最终支付金额和积分奖励
- 用户点击确认后创建支付订单
- 调用微信支付接口

#### 步骤4：创建支付订单
```typescript
// 订单创建流程
interface CreateOrderFlow {
  // 1. 订单数据准备
  orderData: {
    userId: string,
    merchantId: string,
    amount: number,            // 支付金额（分）
    description: string,       // 订单描述
    expectedPoints: number,    // 预期积分
    clientIP: string,          // 用户IP
    notifyUrl: string,         // 回调地址
    expireTime: Date          // 过期时间
  },
  
  // 2. 预处理检查
  preCheck: {
    userStatus: 'active',      // 用户状态检查
    merchantStatus: 'active',  // 商户状态检查
    amountLimit: boolean,      // 金额限制检查
    dailyLimit: boolean        // 每日限额检查
  },
  
  // 3. 订单创建
  orderCreation: {
    orderId: string,           // 系统订单ID
    orderNo: string,           // 订单号
    status: 'created',         // 订单状态
    createdAt: Date,           // 创建时间
    expiredAt: Date            // 过期时间
  }
}
```

#### 步骤5：调用微信支付
```typescript
// 微信支付调用
interface WeChatPayment {
  // 支付参数
  paymentParams: {
    appid: string,             // 小程序appid
    mch_id: string,            // 商户号
    out_trade_no: string,      // 商户订单号
    body: string,              // 商品描述
    total_fee: number,         // 总金额（分）
    spbill_create_ip: string,  // 用户IP
    notify_url: string,        // 通知地址
    trade_type: 'JSAPI',       // 交易类型
    openid: string             // 用户openid
  },
  
  // 返回参数
  paymentResult: {
    return_code: 'SUCCESS',
    result_code: 'SUCCESS',
    prepay_id: string,         // 预支付交易会话标识
    sign: string               // 签名
  },
  
  // 前端调用参数
  jsapiParams: {
    timeStamp: string,
    nonceStr: string,
    package: string,           // prepay_id=xxx
    signType: 'MD5',
    paySign: string
  }
}
```

#### 步骤6：支付结果处理（关键步骤）
```typescript
// 支付回调处理 - 确保积分发放同步
interface PaymentCallback {
  // 回调数据验证
  validation: {
    signatureValid: boolean,   // 签名验证
    orderExists: boolean,      // 订单存在性
    amountMatch: boolean,      // 金额匹配
    statusCorrect: boolean     // 状态正确
  },
  
  // 同步处理流程
  syncProcess: {
    // 1. 更新订单状态
    updateOrder: {
      status: 'paid',
      paidAt: Date,
      transactionId: string    // 微信交易号
    },
    
    // 2. 计算积分
    calculatePoints: {
      baseAmount: number,      // 基础金额
      pointsRatio: 1,          // 积分比例
      finalPoints: number      // 最终积分
    },
    
    // 3. 发放积分（事务保证）
    awardPoints: {
      userId: string,
      orderId: string,
      pointsChange: number,
      source: 'payment_reward',
      description: string,
      expiresAt: Date
    },
    
    // 4. 发送通知
    notification: {
      type: 'payment_success',
      userId: string,
      data: {
        amount: number,
        points: number,
        orderId: string
      }
    }
  }
}
```

**关键技术要求**：
```sql
-- 使用数据库事务确保一致性
BEGIN TRANSACTION;

-- 1. 更新订单状态
UPDATE payment_orders 
SET status = 'paid', 
    paid_at = NOW(), 
    wechat_transaction_id = ? 
WHERE order_no = ?;

-- 2. 发放积分
INSERT INTO points_records (
  user_id, order_id, points_change, 
  change_type, source, description, 
  expires_at, created_at
) VALUES (?, ?, ?, 'award', 'payment_reward', ?, ?, NOW());

-- 3. 更新用户积分余额
UPDATE user_points 
SET total_points = total_points + ?,
    available_points = available_points + ?,
    updated_at = NOW()
WHERE user_id = ?;

COMMIT;
```

#### 步骤7：支付成功页面
```typescript
// 支付成功页面数据
interface PaymentSuccessPage {
  // 支付结果
  paymentResult: {
    success: true,
    amount: number,            // 支付金额
    orderNo: string,           // 订单号
    paidAt: string,            // 支付时间
    merchantName: string       // 商户名称
  },
  
  // 积分信息
  pointsInfo: {
    awarded: number,           // 本次获得积分
    total: number,             // 总积分余额
    value: string,             // 积分价值描述
    expiration: string         // 过期时间
  },
  
  // 后续操作
  nextActions: {
    viewPoints: string,        // 查看积分链接
    continueShopping: string,  // 继续购物
    shareReward: string,       // 分享奖励
    merchantHome: string       // 商户主页
  }
}
```

**成功页面设计**：
```
支付成功页面：
├── 成功标识
│   ├── 绿色对勾图标
│   └── "支付成功"文字
├── 支付信息
│   ├── 支付金额（大字号）
│   ├── 商户名称
│   ├── 订单号
│   └── 支付时间
├── 积分奖励（重点突出）
│   ├── "恭喜获得XX积分"（动画效果）
│   ├── 积分价值说明
│   ├── 当前总积分
│   └── 积分有效期
└── 操作按钮
    ├── 查看积分详情
    ├── 返回商户
    └── 完成
```

---

## ⚡ 同步性保证机制

### 强一致性设计

#### 1. 数据库事务保证
```typescript
// 事务处理示例
const processPaymentSuccess = async (callbackData: PaymentCallbackData) => {
  const transaction = await db.transaction()
  
  try {
    // 1. 验证回调数据
    const isValid = await validateCallback(callbackData)
    if (!isValid) throw new Error('Invalid callback data')
    
    // 2. 查询订单
    const order = await Order.findOne({
      where: { orderNo: callbackData.out_trade_no },
      transaction
    })
    
    // 3. 更新订单状态
    await order.update({
      status: 'paid',
      paidAt: new Date(),
      wechatTransactionId: callbackData.transaction_id
    }, { transaction })
    
    // 4. 计算积分
    const pointsToAward = Math.floor(order.amount / 100) // 1元=1积分
    
    // 5. 发放积分
    await PointsRecord.create({
      userId: order.userId,
      orderId: order.id,
      pointsChange: pointsToAward,
      changeType: 'award',
      source: 'payment_reward',
      description: `支付订单${order.orderNo}获得积分`,
      expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) // 1年有效期
    }, { transaction })
    
    // 6. 更新用户积分余额
    await UserPoints.increment({
      totalPoints: pointsToAward,
      availablePoints: pointsToAward
    }, {
      where: { userId: order.userId },
      transaction
    })
    
    // 7. 提交事务
    await transaction.commit()
    
    // 8. 发送成功通知
    await sendPaymentSuccessNotification(order.userId, {
      amount: order.amount,
      points: pointsToAward,
      orderNo: order.orderNo
    })
    
    return { success: true, pointsAwarded: pointsToAward }
    
  } catch (error) {
    // 回滚事务
    await transaction.rollback()
    
    // 记录错误日志
    logger.error('Payment processing failed:', error)
    
    // 发送告警
    await sendAlert('payment_processing_failed', {
      orderNo: callbackData.out_trade_no,
      error: error.message
    })
    
    throw error
  }
}
```

#### 2. 幂等性保证
```typescript
// 防重复处理机制
const processWithIdempotency = async (callbackData: PaymentCallbackData) => {
  const lockKey = `payment_callback:${callbackData.out_trade_no}`
  const lock = await redis.lock(lockKey, 30000) // 30秒锁
  
  try {
    // 检查是否已处理
    const processed = await redis.get(`processed:${callbackData.out_trade_no}`)
    if (processed) {
      return JSON.parse(processed)
    }
    
    // 处理支付回调
    const result = await processPaymentSuccess(callbackData)
    
    // 标记为已处理
    await redis.setex(`processed:${callbackData.out_trade_no}`, 3600, JSON.stringify(result))
    
    return result
    
  } finally {
    await lock.unlock()
  }
}
```

#### 3. 异常恢复机制
```typescript
// 异常恢复任务
const recoverFailedPayments = async () => {
  // 查找支付成功但积分未发放的订单
  const failedOrders = await db.query(`
    SELECT o.* FROM payment_orders o
    LEFT JOIN points_records p ON o.id = p.order_id
    WHERE o.status = 'paid' 
      AND o.paid_at > DATE_SUB(NOW(), INTERVAL 1 HOUR)
      AND p.id IS NULL
  `)
  
  for (const order of failedOrders) {
    try {
      // 补发积分
      await awardPointsForOrder(order)
      logger.info(`Recovered points for order: ${order.orderNo}`)
    } catch (error) {
      logger.error(`Failed to recover order: ${order.orderNo}`, error)
    }
  }
}

// 定时执行恢复任务
setInterval(recoverFailedPayments, 5 * 60 * 1000) // 每5分钟执行一次
```

---

## 📱 用户界面流程

### 支付页面设计规范

#### 页面结构
```jsx
// 支付页面组件结构
const PaymentPage = ({ qrCodeData }) => {
  return (
    <View className="payment-page">
      {/* 商户信息区域 */}
      <MerchantInfo merchant={merchantData} />
      
      {/* 用户信息区域 */}
      <UserInfo user={userData} />
      
      {/* 支付金额区域 */}
      <PaymentAmount 
        amount={amount}
        onAmountChange={handleAmountChange}
        expectedPoints={calculatePoints(amount)}
      />
      
      {/* 积分说明区域 */}
      <PointsExplanation />
      
      {/* 支付按钮 */}
      <PaymentButton 
        amount={amount}
        onPayment={handlePayment}
        loading={paymentLoading}
      />
    </View>
  )
}
```

#### 关键交互逻辑
```typescript
// 支付处理逻辑
const handlePayment = async (amount: number) => {
  try {
    setPaymentLoading(true)
    
    // 1. 创建订单
    const order = await createPaymentOrder({
      merchantId: qrCodeData.merchantId,
      amount: amount * 100, // 转为分
      userId: currentUser.id
    })
    
    // 2. 调用微信支付
    const paymentParams = await getWeChatPaymentParams(order.id)
    
    // 3. 唤起微信支付
    const paymentResult = await wx.requestPayment(paymentParams)
    
    // 4. 支付成功处理
    if (paymentResult.errMsg === 'requestPayment:ok') {
      // 跳转到支付成功页面
      wx.redirectTo({
        url: `/pages/payment-success/index?orderId=${order.id}`
      })
    }
    
  } catch (error) {
    // 支付失败处理
    handlePaymentError(error)
  } finally {
    setPaymentLoading(false)
  }
}
```

### 支付成功页面设计
```jsx
// 支付成功页面
const PaymentSuccessPage = ({ orderId }) => {
  const [orderData, setOrderData] = useState(null)
  const [pointsData, setPointsData] = useState(null)
  
  useEffect(() => {
    // 获取订单和积分信息
    fetchOrderAndPoints(orderId)
  }, [orderId])
  
  return (
    <View className="payment-success-page">
      {/* 成功标识 */}
      <SuccessIcon />
      
      {/* 支付信息 */}
      <PaymentInfo order={orderData} />
      
      {/* 积分奖励（重点展示） */}
      <PointsReward 
        points={pointsData.awarded}
        total={pointsData.total}
        animation={true}
      />
      
      {/* 操作按钮 */}
      <ActionButtons 
        onViewPoints={() => navigateToPoints()}
        onContinue={() => navigateToMerchant()}
        onComplete={() => navigateToHome()}
      />
    </View>
  )
}
```

---

## 🔍 监控和告警

### 关键指标监控
```typescript
// 监控指标定义
const PaymentMetrics = {
  // 业务指标
  business: {
    paymentSuccessRate: '支付成功率',
    pointsAwardRate: '积分发放成功率',
    averageAmount: '平均支付金额',
    pointsAccuracy: '积分发放准确率'
  },
  
  // 技术指标
  technical: {
    callbackResponseTime: '回调处理响应时间',
    databaseTransactionTime: '数据库事务耗时',
    errorRate: '错误率',
    systemThroughput: '系统吞吐量'
  },
  
  // 用户体验指标
  userExperience: {
    pageLoadTime: '支付页面加载时间',
    paymentCompletionTime: '支付完成时间',
    userSatisfactionScore: '用户满意度评分'
  }
}
```

### 告警规则设置
```typescript
// 告警规则配置
const AlertRules = [
  {
    name: '积分发放失败率过高',
    condition: 'pointsAwardFailureRate > 1%',
    level: 'critical',
    actions: ['短信通知', '钉钉告警', '自动修复']
  },
  {
    name: '支付回调处理延迟',
    condition: 'callbackProcessingTime > 5s',
    level: 'warning',
    actions: ['邮件通知', '性能分析']
  },
  {
    name: '数据一致性异常',
    condition: 'dataInconsistencyCount > 0',
    level: 'critical',
    actions: ['立即通知', '停止处理', '人工介入']
  }
]
```

---

## ✅ 质量保证

### 测试用例设计
```typescript
// 核心测试场景
const TestCases = {
  // 正常流程测试
  normalFlow: [
    '用户扫码 → 支付成功 → 积分正确发放',
    '固定金额支付 → 积分计算准确',
    '自定义金额支付 → 积分计算准确'
  ],
  
  // 异常情况测试
  edgeCases: [
    '支付过程中网络中断',
    '回调延迟或重复',
    '金额为0或负数',
    '用户余额不足',
    '系统维护期间支付'
  ],
  
  // 并发测试
  concurrency: [
    '同一用户并发支付',
    '同一商户并发收款',
    '系统高并发压力测试'
  ],
  
  // 数据一致性测试
  consistency: [
    '支付成功但积分发放失败',
    '数据库事务回滚测试',
    '系统故障恢复测试'
  ]
}
```

---

**文档状态**：待技术评审  
**下一步行动**：详细接口设计和开发实现  
**责任人**：系统架构师  
**评审时间**：待定
