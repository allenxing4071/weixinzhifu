# 商城微服务边界与接口规范

## 📖 文档信息
- **文档版本**：V1.0
- **创建日期**：2024年12月24日
- **架构师**：技术团队
- **评审状态**：待评审

---

## 🏗️ 微服务边界定义

### 服务职责矩阵

| 服务名称 | 核心职责 | 数据所有权 | 对外接口 | 依赖服务 |
|---------|---------|-----------|---------|---------|
| **用户服务** | 用户认证、信息管理 | users表 | 用户CRUD、认证 | 无 |
| **支付服务** | 微信支付、订单管理 | payment_orders表 | 支付、回调 | 用户服务 |
| **积分服务** | 积分发放、消费、查询 | points_records, user_points表 | 积分CRUD | 用户服务 |
| **商户服务** | 商户管理、收款码 | merchants表 | 商户CRUD | 用户服务 |
| **商品服务** | 商品管理、分类 | products, categories表 | 商品CRUD | 无 |
| **库存服务** | 库存管理、预留 | inventory_records表 | 库存操作 | 商品服务 |
| **兑换服务** | 兑换订单、发货 | exchange_orders表 | 兑换流程 | 积分、商品、库存服务 |
| **推荐服务** | 个性化推荐 | user_preferences表 | 推荐算法 | 用户、商品、兑换服务 |

---

## 🔌 服务间通信协议

### 1. 同步通信（HTTP/REST）

#### 请求格式规范
```typescript
// 统一请求格式
interface APIRequest<T = any> {
  data?: T
  pagination?: {
    page: number
    pageSize: number
  }
  filters?: Record<string, any>
  sort?: {
    field: string
    order: 'asc' | 'desc'
  }
}

// 统一响应格式
interface APIResponse<T = any> {
  success: boolean
  code: string
  message: string
  data?: T
  pagination?: {
    page: number
    pageSize: number
    total: number
    totalPages: number
  }
  timestamp: number
}
```

#### 服务间调用示例
```typescript
// 兑换服务调用积分服务
class ExchangeService {
  async processExchange(exchangeData: ExchangeData): Promise<ExchangeResult> {
    // 1. 调用积分服务检查余额
    const pointsBalance = await this.callService('points-service', {
      method: 'GET',
      path: `/api/points/balance/${exchangeData.userId}`,
      headers: { 'Service-Auth': this.generateServiceToken() }
    })
    
    if (pointsBalance.data.balance < exchangeData.pointsCost) {
      throw new Error('积分余额不足')
    }
    
    // 2. 调用库存服务预留商品
    const stockReserved = await this.callService('inventory-service', {
      method: 'POST',
      path: '/api/inventory/reserve',
      data: {
        productId: exchangeData.productId,
        quantity: exchangeData.quantity,
        orderId: exchangeData.orderId
      }
    })
    
    if (!stockReserved.success) {
      throw new Error('库存预留失败')
    }
    
    // 3. 执行积分扣减
    const pointsConsumed = await this.callService('points-service', {
      method: 'POST', 
      path: '/api/points/consume',
      data: {
        userId: exchangeData.userId,
        points: exchangeData.pointsCost,
        description: `商城兑换-${exchangeData.productId}`,
        orderId: exchangeData.orderId
      }
    })
    
    if (!pointsConsumed.success) {
      // 释放库存
      await this.callService('inventory-service', {
        method: 'POST',
        path: '/api/inventory/release',
        data: { productId: exchangeData.productId, orderId: exchangeData.orderId }
      })
      throw new Error('积分扣减失败')
    }
    
    return { success: true }
  }
}
```

### 2. 异步通信（事件驱动）

#### 事件总线设计
```typescript
// 事件总线接口
interface EventBus {
  publish(event: ServiceEvent): Promise<void>
  subscribe(eventType: string, handler: EventHandler): void
  unsubscribe(eventType: string, handler: EventHandler): void
}

// Redis实现的事件总线
class RedisEventBus implements EventBus {
  private redis: Redis
  private subscribers: Map<string, EventHandler[]> = new Map()

  async publish(event: ServiceEvent): Promise<void> {
    await this.redis.publish('service-events', JSON.stringify(event))
    
    // 本地处理器也执行
    const handlers = this.subscribers.get(event.eventType) || []
    for (const handler of handlers) {
      try {
        await handler(event)
      } catch (error) {
        console.error(`事件处理失败: ${event.eventType}`, error)
      }
    }
  }

  subscribe(eventType: string, handler: EventHandler): void {
    if (!this.subscribers.has(eventType)) {
      this.subscribers.set(eventType, [])
    }
    this.subscribers.get(eventType)!.push(handler)
  }
}
```

---

## 🔒 安全和权限设计

### 1. 服务间认证

#### 服务认证令牌
```typescript
// 服务间认证
interface ServiceAuthToken {
  serviceId: string
  serviceName: string
  permissions: string[]
  iat: number
  exp: number
}

// 生成服务令牌
class ServiceAuthManager {
  generateServiceToken(serviceId: string, permissions: string[]): string {
    const payload: ServiceAuthToken = {
      serviceId,
      serviceName: this.getServiceName(serviceId),
      permissions,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 3600 // 1小时过期
    }
    
    return jwt.sign(payload, config.serviceAuth.secret)
  }
  
  verifyServiceToken(token: string): ServiceAuthToken {
    return jwt.verify(token, config.serviceAuth.secret) as ServiceAuthToken
  }
}
```

### 2. 数据访问权限

#### 数据访问控制列表
```typescript
const ServiceACL = {
  'user-service': {
    read: ['users', 'user_points'],
    write: ['users']
  },
  'points-service': {
    read: ['users', 'points_records', 'user_points'],
    write: ['points_records', 'user_points']
  },
  'mall-service': {
    read: ['users', 'user_points', 'products', 'categories'],
    write: ['exchange_orders']
  },
  'inventory-service': {
    read: ['products', 'inventory_records'],
    write: ['inventory_records']
  }
}
```

---

## 📊 数据同步和一致性

### 1. 积分数据一致性

#### 最终一致性设计
```typescript
// 积分余额同步机制
class PointsBalanceSync {
  // 定时同步任务
  async syncUserPointsBalance(userId: string): Promise<void> {
    const records = await PointsRecordModel.getUserActiveRecords(userId)
    const calculatedBalance = records.reduce((sum, record) => sum + record.pointsChange, 0)
    
    const currentUser = await UserModel.findById(userId)
    
    if (currentUser.pointsBalance !== calculatedBalance) {
      console.warn(`积分余额不一致: 用户${userId}, 计算值${calculatedBalance}, 存储值${currentUser.pointsBalance}`)
      
      // 修正余额
      await UserModel.updatePointsBalance(userId, calculatedBalance)
      
      // 记录修正日志
      await AuditLogService.log({
        type: 'POINTS_BALANCE_CORRECTION',
        userId,
        oldBalance: currentUser.pointsBalance,
        newBalance: calculatedBalance,
        timestamp: new Date()
      })
    }
  }
}
```

### 2. 库存数据同步

#### 库存实时同步
```typescript
class InventorySync {
  // 库存变更事件处理
  async handleStockChange(event: StockChangeEvent): Promise<void> {
    const { productId, changeType, quantity, orderId } = event.payload
    
    // 更新库存记录
    await InventoryRecordModel.create({
      productId,
      changeType,
      quantityChange: quantity,
      relatedOrderId: orderId,
      operatorId: event.operatorId,
      description: event.description
    })
    
    // 更新商品库存
    await ProductModel.updateStock(productId, quantity, changeType)
    
    // 检查库存预警
    const currentStock = await ProductModel.getStock(productId)
    if (currentStock <= STOCK_ALERT_THRESHOLD) {
      await this.sendStockAlert(productId, currentStock)
    }
  }
}
```

---

## 🔄 服务治理和监控

### 1. 服务注册与发现

#### 服务注册中心
```typescript
// 简化版服务注册（基于Redis）
class ServiceRegistry {
  private redis: Redis
  
  async registerService(serviceInfo: ServiceInfo): Promise<void> {
    const key = `service:${serviceInfo.name}:${serviceInfo.instanceId}`
    
    await this.redis.setex(key, 30, JSON.stringify({
      ...serviceInfo,
      lastHeartbeat: Date.now()
    }))
  }
  
  async discoverService(serviceName: string): Promise<ServiceInfo[]> {
    const pattern = `service:${serviceName}:*`
    const keys = await this.redis.keys(pattern)
    
    const services = []
    for (const key of keys) {
      const serviceData = await this.redis.get(key)
      if (serviceData) {
        services.push(JSON.parse(serviceData))
      }
    }
    
    return services.filter(service => 
      Date.now() - service.lastHeartbeat < 60000 // 1分钟内有心跳
    )
  }
}
```

### 2. 熔断和降级

#### 熔断器模式
```typescript
class CircuitBreaker {
  private failureCount = 0
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED'
  private lastFailureTime = 0
  
  async execute<T>(operation: () => Promise<T>, fallback?: () => T): Promise<T> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN'
      } else {
        return this.handleFallback(fallback)
      }
    }
    
    try {
      const result = await operation()
      this.onSuccess()
      return result
    } catch (error) {
      this.onFailure()
      return this.handleFallback(fallback)
    }
  }
  
  private handleFallback<T>(fallback?: () => T): T {
    if (fallback) {
      return fallback()
    }
    throw new Error('服务不可用，且无降级方案')
  }
}

// 商城服务降级策略
const MallServiceFallback = {
  getRecommendations: () => ({
    success: true,
    data: [], // 返回空推荐，不影响主流程
    message: '推荐服务暂时不可用'
  }),
  
  getProductDetail: (productId: string) => ({
    success: false,
    message: '商品详情暂时无法获取，请稍后重试'
  })
}
```

---

## 📈 性能优化策略

### 1. 缓存策略

#### 多级缓存设计
```typescript
class MallCacheManager {
  // L1: 应用内存缓存（热点数据）
  private memoryCache = new Map<string, CacheItem>()
  
  // L2: Redis分布式缓存
  private redisCache: Redis
  
  // L3: CDN缓存（静态资源）
  private cdnCache: CDNClient

  async getProduct(productId: string): Promise<ProductEntity | null> {
    // L1缓存查找
    const memoryCached = this.memoryCache.get(`product:${productId}`)
    if (memoryCached && !this.isExpired(memoryCached)) {
      return memoryCached.data
    }
    
    // L2缓存查找
    const redisCached = await this.redisCache.get(`product:${productId}`)
    if (redisCached) {
      const product = JSON.parse(redisCached)
      // 回写L1缓存
      this.memoryCache.set(`product:${productId}`, {
        data: product,
        expiredAt: Date.now() + 60000 // 1分钟
      })
      return product
    }
    
    // 缓存未命中，查询数据库
    const product = await ProductModel.findById(productId)
    if (product) {
      // 写入各级缓存
      this.memoryCache.set(`product:${productId}`, {
        data: product,
        expiredAt: Date.now() + 60000
      })
      await this.redisCache.setex(`product:${productId}`, 300, JSON.stringify(product)) // 5分钟
    }
    
    return product
  }
}
```

### 2. 数据库优化

#### 分库分表策略
```sql
-- 兑换订单按用户ID分表（16张表）
CREATE TABLE exchange_orders_00 LIKE exchange_orders;
CREATE TABLE exchange_orders_01 LIKE exchange_orders;
-- ... 
CREATE TABLE exchange_orders_15 LIKE exchange_orders;

-- 积分记录按月分表
CREATE TABLE points_records_202412 LIKE points_records;
CREATE TABLE points_records_202501 LIKE points_records;
-- ...
```

```typescript
// 分表路由逻辑
class ShardingRouter {
  getExchangeOrderTable(userId: string): string {
    const hash = this.hash(userId) % 16
    return `exchange_orders_${hash.toString().padStart(2, '0')}`
  }
  
  getPointsRecordTable(date: Date): string {
    const year = date.getFullYear()
    const month = (date.getMonth() + 1).toString().padStart(2, '0')
    return `points_records_${year}${month}`
  }
}
```

---

## 🎯 接口规范定义

### 1. 商城核心接口

#### 商品相关接口
```typescript
// 获取商品列表
GET /api/mall/products
Query Parameters:
- category_id?: string
- keyword?: string  
- min_points?: number
- max_points?: number
- is_hot?: boolean
- page?: number
- page_size?: number

Response:
{
  "success": true,
  "data": {
    "products": [
      {
        "id": "product_001",
        "name": "iPhone 15 Pro",
        "description": "最新款iPhone",
        "category": {
          "id": "electronics",
          "name": "数码产品"
        },
        "pointsPrice": 699900,
        "originalPrice": 6999.00,
        "images": ["url1", "url2"],
        "stockQuantity": 50,
        "salesCount": 123,
        "isHot": true,
        "isNew": false
      }
    ]
  },
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "total": 156,
    "totalPages": 8
  }
}
```

#### 兑换相关接口
```typescript
// 创建兑换订单
POST /api/mall/exchange
Request Body:
{
  "productId": "product_001",
  "quantity": 1,
  "deliveryInfo": {
    "receiverName": "张三",
    "receiverPhone": "13800138000",
    "address": "北京市朝阳区xxx街道xxx号"
  }
}

Response:
{
  "success": true,
  "data": {
    "orderId": "exchange_001",
    "orderNo": "EX202412240001", 
    "pointsCost": 699900,
    "estimatedDelivery": "2024-12-27",
    "remainingPoints": 1200
  }
}
```

### 2. 推荐系统接口

#### 个性化推荐
```typescript
// 获取推荐商品
GET /api/mall/recommendations
Query Parameters:
- user_id: string
- context?: 'payment_preview' | 'payment_success' | 'mall_home'
- expected_points?: number
- limit?: number

Response:
{
  "success": true,
  "data": {
    "recommendations": [
      {
        "type": "affordable", // 可负担
        "products": [...],
        "reason": "基于当前积分余额推荐"
      },
      {
        "type": "aspirational", // 激励性
        "products": [...], 
        "reason": "再消费一次即可兑换"
      },
      {
        "type": "popular", // 热门
        "products": [...],
        "reason": "热门兑换商品"
      }
    ],
    "userContext": {
      "currentPoints": 1288,
      "expectedPoints": 50,
      "userLevel": "silver"
    }
  }
}
```

---

## 🚦 错误处理和重试机制

### 1. 统一错误码

```typescript
// 商城服务错误码定义
enum MallErrorCode {
  // 商品相关
  PRODUCT_NOT_FOUND = 'MALL_PRODUCT_NOT_FOUND',
  PRODUCT_OUT_OF_STOCK = 'MALL_PRODUCT_OUT_OF_STOCK',
  PRODUCT_INVALID = 'MALL_PRODUCT_INVALID',
  
  // 兑换相关
  INSUFFICIENT_POINTS = 'MALL_INSUFFICIENT_POINTS',
  EXCHANGE_FAILED = 'MALL_EXCHANGE_FAILED',
  ORDER_NOT_FOUND = 'MALL_ORDER_NOT_FOUND',
  
  // 库存相关
  STOCK_RESERVE_FAILED = 'MALL_STOCK_RESERVE_FAILED',
  STOCK_RELEASE_FAILED = 'MALL_STOCK_RELEASE_FAILED',
  
  // 系统相关
  SERVICE_UNAVAILABLE = 'MALL_SERVICE_UNAVAILABLE',
  INTERNAL_ERROR = 'MALL_INTERNAL_ERROR'
}
```

### 2. 重试机制

```typescript
class RetryManager {
  async withRetry<T>(
    operation: () => Promise<T>,
    options: {
      maxAttempts: number
      backoffMs: number
      retryableErrors: string[]
    }
  ): Promise<T> {
    let lastError: Error
    
    for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {
      try {
        return await operation()
      } catch (error) {
        lastError = error
        
        if (attempt === options.maxAttempts || !this.isRetryable(error, options.retryableErrors)) {
          throw error
        }
        
        // 指数退避
        const delay = options.backoffMs * Math.pow(2, attempt - 1)
        await this.sleep(delay)
      }
    }
    
    throw lastError!
  }
  
  private isRetryable(error: Error, retryableErrors: string[]): boolean {
    return retryableErrors.some(code => error.message.includes(code))
  }
}
```

---

## 🎛️ 配置管理

### 1. 商城服务配置

```typescript
// 商城服务配置
export const mallConfig = {
  // 商品配置
  products: {
    maxImagesPerProduct: 10,
    imageSizeLimit: 2 * 1024 * 1024, // 2MB
    defaultPageSize: 20,
    maxPageSize: 100
  },
  
  // 兑换配置
  exchange: {
    orderExpireMinutes: 30, // 订单30分钟自动取消
    maxQuantityPerOrder: 5,
    refundTimeoutDays: 7
  },
  
  // 库存配置
  inventory: {
    lowStockThreshold: 10,
    reserveTimeoutMinutes: 10,
    autoReleaseEnabled: true
  },
  
  // 推荐配置
  recommendation: {
    maxRecommendations: 20,
    cacheTimeMinutes: 15,
    personalizedRatio: 0.7 // 个性化推荐占比
  }
}
```

### 2. 环境配置

```typescript
// 不同环境的配置
const environmentConfigs = {
  development: {
    enableMockData: true,
    logLevel: 'debug',
    cacheEnabled: false,
    strictValidation: false
  },
  
  testing: {
    enableMockData: false,
    logLevel: 'info', 
    cacheEnabled: true,
    strictValidation: true
  },
  
  production: {
    enableMockData: false,
    logLevel: 'warn',
    cacheEnabled: true,
    strictValidation: true,
    enableAPMMonitoring: true
  }
}
```

---

## ✅ 集成验收标准

### 1. 功能验收

#### 核心功能检查清单
- [ ] 商品列表正常加载
- [ ] 商品详情完整显示
- [ ] 兑换流程端到端测试通过
- [ ] 积分扣减准确无误
- [ ] 库存扣减同步及时
- [ ] 订单状态更新正常
- [ ] 推荐算法生效

### 2. 性能验收

#### 性能指标要求
- [ ] 商品列表加载时间 ≤ 800ms
- [ ] 商品详情加载时间 ≤ 500ms
- [ ] 兑换订单创建时间 ≤ 300ms
- [ ] 推荐接口响应时间 ≤ 200ms
- [ ] 并发兑换处理能力 ≥ 100 TPS

### 3. 安全验收

#### 安全检查清单
- [ ] 服务间认证正常工作
- [ ] 权限控制生效
- [ ] 敏感数据加密存储
- [ ] 接口限流配置正确
- [ ] 数据访问审计完整

---

**文档状态**：待技术评审  
**下一步行动**：开始基础框架搭建  
**责任人**：架构师 + 开发团队  
**评审时间**：待定
