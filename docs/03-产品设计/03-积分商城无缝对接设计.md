# 03-积分商城无缝对接设计

## 📖 文档信息
- **文档版本**：V1.0
- **创建日期**：2024年12月
- **产品经理**：[姓名]
- **UX设计师**：[姓名]
- **评审状态**：待评审

---

## 🎯 设计目标

设计支付页面与积分商城的无缝对接体验，形成"支付获得积分 → 积分商城消费"的完整用户旅程闭环，最大化积分价值感知和用户留存。

### 核心对接原则
1. **价值引导**：支付时就让用户看到积分的使用价值
2. **无缝跳转**：一键直达积分商城相关商品
3. **个性推荐**：基于积分数量智能推荐商品
4. **即时满足**：积分到账后立即可用于商城消费

---

## 🔄 用户旅程设计

### 完整用户旅程映射
```
支付前 → 支付中 → 支付后 → 积分使用 → 再次消费
  ↓        ↓        ↓         ↓         ↓
积分预告   积分确认   积分到账   商城消费   循环增长

详细流程：
1. 扫码支付页面 → 看到积分商城入口预告
2. 支付确认时 → 显示积分可兑换的具体商品
3. 支付成功后 → 积分到账 + 推荐商品 + 商城入口
4. 进入商城页 → 个性化推荐 + 积分余额显示
5. 完成兑换后 → 引导再次消费获得更多积分
```

---

## 📱 支付页面积分商城元素设计

### 1. 支付页面新增积分商城预告区

#### 设计布局
```jsx
// 在原有支付页面基础上新增商城预告区
<View className="payment-page">
  {/* 原有内容：商户信息、支付金额、积分奖励 */}
  
  {/* 新增：积分商城预告区 */}
  <View className="points-mall-preview">
    <View className="mall-header">
      <Icon name="shopping-mall" className="mall-icon" />
      <Text className="mall-title">积分商城</Text>
      <Text className="mall-subtitle">积分当钱花</Text>
    </View>
    
    {/* 推荐商品轮播 */}
    <ScrollView className="recommended-products" horizontal>
      {recommendedProducts.map(product => (
        <TouchableOpacity 
          key={product.id}
          className="product-card"
          onPress={() => showProductDetail(product)}
        >
          <Image src={product.image} className="product-image" />
          <Text className="product-name">{product.name}</Text>
          <View className="product-price">
            <Text className="points-price">{product.pointsPrice}积分</Text>
            <Text className="original-price">¥{product.originalPrice}</Text>
          </View>
          {/* 积分充足性提示 */}
          {userPoints + expectedPoints >= product.pointsPrice && (
            <View className="affordable-tag">
              <Text>支付后可兑换</Text>
            </View>
          )}
        </TouchableOpacity>
      ))}
    </ScrollView>
    
    {/* 商城入口 */}
    <TouchableOpacity 
      className="mall-entrance"
      onPress={() => navigateToMall()}
    >
      <Text className="entrance-text">查看更多商品</Text>
      <Icon name="arrow-right" />
    </TouchableOpacity>
  </View>
</View>
```

#### 推荐算法设计
```typescript
// 基于积分数量的智能推荐
interface ProductRecommendation {
  // 推荐策略
  strategy: {
    affordable: '用户当前+预期积分可兑换的商品',
    aspirational: '稍高于用户积分的商品（激励再消费）',
    popular: '热门兑换商品',
    category: '基于用户消费偏好的品类商品'
  },
  
  // 推荐权重
  weights: {
    affordable: 0.4,      // 40% - 可负担商品
    aspirational: 0.3,    // 30% - 激励商品  
    popular: 0.2,         // 20% - 热门商品
    category: 0.1         // 10% - 个性化商品
  }
}

// 推荐商品计算
const calculateRecommendedProducts = (userPoints: number, expectedPoints: number, userPreference: any) => {
  const totalPoints = userPoints + expectedPoints
  
  return {
    // 可兑换商品（积分充足）
    affordable: products.filter(p => p.pointsPrice <= totalPoints),
    
    // 激励商品（需要再消费1-2次）
    aspirational: products.filter(p => 
      p.pointsPrice > totalPoints && 
      p.pointsPrice <= totalPoints * 2
    ),
    
    // 热门商品
    popular: products.sort((a, b) => b.exchangeCount - a.exchangeCount).slice(0, 5),
    
    // 个性化推荐
    personalized: getPersonalizedProducts(userPreference, totalPoints)
  }
}
```

### 2. 支付成功页面积分商城引导

#### 支付成功页面改版
```jsx
<View className="payment-success-page">
  {/* 原有成功信息 */}
  <SuccessAnimation />
  <PaymentInfo order={orderData} />
  
  {/* 重新设计的积分展示区 */}
  <View className="points-success-section">
    <View className="points-animation">
      <LottieView source={pointsRainAnimation} autoPlay />
      <Text className="points-gained">+{pointsAwarded} 积分已到账</Text>
      <Text className="total-points">当前总积分：{totalPoints}</Text>
    </View>
    
    {/* 立即使用积分CTA */}
    <View className="immediate-use-section">
      <Text className="cta-title">立即使用积分，享受更多优惠！</Text>
      
      {/* 推荐商品卡片 */}
      <View className="instant-recommendations">
        {instantProducts.map(product => (
          <TouchableOpacity 
            key={product.id}
            className="instant-product-card"
            onPress={() => exchangeProduct(product)}
          >
            <Image src={product.image} className="product-thumb" />
            <View className="product-info">
              <Text className="product-name">{product.name}</Text>
              <Text className="points-price">{product.pointsPrice}积分</Text>
              <View className="exchange-status">
                {totalPoints >= product.pointsPrice ? (
                  <Button className="exchange-btn">立即兑换</Button>
                ) : (
                  <Text className="need-more">还需{product.pointsPrice - totalPoints}积分</Text>
                )}
              </View>
            </View>
          </TouchableOpacity>
        ))}
      </View>
      
      {/* 商城入口按钮 */}
      <Button 
        className="mall-entrance-btn"
        onPress={() => navigateToMall({ source: 'payment_success' })}
      >
        <Icon name="shopping-bag" />
        <Text>进入积分商城</Text>
      </Button>
    </View>
  </View>
  
  {/* 其他操作 */}
  <View className="other-actions">
    <Button type="secondary" onPress={() => navigateToHome()}>
      返回首页
    </Button>
    <Button type="secondary" onPress={() => navigateToMerchant()}>
      继续购物
    </Button>
  </View>
</View>
```

---

## 🏪 积分商城核心功能设计

### 1. 积分商城首页设计

#### 页面架构
```jsx
<View className="points-mall-home">
  {/* 用户积分信息栏 */}
  <View className="user-points-header">
    <View className="points-display">
      <Text className="points-amount">{userPoints}</Text>
      <Text className="points-unit">可用积分</Text>
    </View>
    <View className="points-value">
      <Text className="value-text">价值 ¥{userPoints}</Text>
    </View>
    <TouchableOpacity 
      className="points-detail-btn"
      onPress={() => navigateToPointsDetail()}
    >
      <Text>明细</Text>
      <Icon name="arrow-right" />
    </TouchableOpacity>
  </View>
  
  {/* 积分获取引导 */}
  <View className="earn-more-section">
    <Text className="earn-title">积分不够？继续消费获得更多积分</Text>
    <Button 
      className="earn-btn"
      onPress={() => navigateToMerchantList()}
    >
      去消费赚积分
    </Button>
  </View>
  
  {/* 商品分类导航 */}
  <ScrollView className="category-nav" horizontal>
    {categories.map(category => (
      <TouchableOpacity 
        key={category.id}
        className="category-item"
        onPress={() => filterByCategory(category.id)}
      >
        <Image src={category.icon} className="category-icon" />
        <Text className="category-name">{category.name}</Text>
      </TouchableOpacity>
    ))}
  </ScrollView>
  
  {/* 个性化推荐区 */}
  <View className="recommendation-section">
    <Text className="section-title">为您推荐</Text>
    <View className="products-grid">
      {recommendedProducts.map(product => (
        <ProductCard 
          key={product.id}
          product={product}
          userPoints={userPoints}
          onExchange={handleExchange}
        />
      ))}
    </View>
  </View>
  
  {/* 热门兑换区 */}
  <View className="popular-section">
    <Text className="section-title">热门兑换</Text>
    <ScrollView className="popular-products" horizontal>
      {popularProducts.map(product => (
        <ProductCard 
          key={product.id}
          product={product}
          userPoints={userPoints}
          layout="horizontal"
        />
      ))}
    </ScrollView>
  </View>
  
  {/* 积分历史和规则 */}
  <View className="info-section">
    <TouchableOpacity onPress={() => navigateToPointsHistory()}>
      <Text>积分明细</Text>
      <Icon name="arrow-right" />
    </TouchableOpacity>
    <TouchableOpacity onPress={() => navigateToPointsRules()}>
      <Text>积分规则</Text>
      <Icon name="arrow-right" />
    </TouchableOpacity>
  </View>
</View>
```

### 2. 商品卡片组件设计

#### ProductCard组件
```jsx
const ProductCard = ({ product, userPoints, onExchange, layout = 'vertical' }) => {
  const canAfford = userPoints >= product.pointsPrice
  const shortage = Math.max(0, product.pointsPrice - userPoints)
  
  return (
    <TouchableOpacity 
      className={`product-card ${layout}`}
      onPress={() => navigateToProductDetail(product.id)}
    >
      <View className="product-image-container">
        <Image src={product.image} className="product-image" />
        {product.isHot && <View className="hot-tag">热门</View>}
        {product.isNew && <View className="new-tag">新品</View>}
      </View>
      
      <View className="product-info">
        <Text className="product-name" numberOfLines={2}>
          {product.name}
        </Text>
        <Text className="product-description" numberOfLines={1}>
          {product.description}
        </Text>
        
        <View className="price-section">
          <View className="points-price">
            <Icon name="coin" className="coin-icon" />
            <Text className="points-amount">{product.pointsPrice}</Text>
            <Text className="points-unit">积分</Text>
          </View>
          <Text className="original-price">原价¥{product.originalPrice}</Text>
        </View>
        
        <View className="action-section">
          {canAfford ? (
            <Button 
              className="exchange-btn primary"
              onPress={() => onExchange(product)}
            >
              立即兑换
            </Button>
          ) : (
            <View className="shortage-info">
              <Text className="shortage-text">还需{shortage}积分</Text>
              <Button 
                className="earn-btn secondary"
                onPress={() => navigateToEarnPoints()}
              >
                去赚积分
              </Button>
            </View>
          )}
        </View>
      </View>
    </TouchableOpacity>
  )
}
```

### 3. 积分兑换流程设计

#### 兑换确认页面
```jsx
const ExchangeConfirmPage = ({ productId }) => {
  const [product, setProduct] = useState(null)
  const [userInfo, setUserInfo] = useState(null)
  const [exchanging, setExchanging] = useState(false)
  
  const handleConfirmExchange = async () => {
    setExchanging(true)
    
    try {
      // 调用兑换接口
      const result = await exchangeProduct({
        productId: product.id,
        pointsRequired: product.pointsPrice,
        userId: userInfo.id
      })
      
      if (result.success) {
        // 跳转到兑换成功页面
        navigateToExchangeSuccess({
          product: product,
          order: result.order,
          remainingPoints: result.remainingPoints
        })
      }
    } catch (error) {
      showError('兑换失败，请重试')
    } finally {
      setExchanging(false)
    }
  }
  
  return (
    <View className="exchange-confirm-page">
      {/* 商品信息 */}
      <View className="product-section">
        <Image src={product.image} className="product-image" />
        <View className="product-details">
          <Text className="product-name">{product.name}</Text>
          <Text className="product-spec">{product.specification}</Text>
        </View>
      </View>
      
      {/* 积分消费明细 */}
      <View className="points-detail">
        <View className="detail-row">
          <Text>兑换积分</Text>
          <Text className="points-cost">-{product.pointsPrice}积分</Text>
        </View>
        <View className="detail-row">
          <Text>当前积分</Text>
          <Text>{userInfo.points}积分</Text>
        </View>
        <View className="detail-row total">
          <Text>兑换后余额</Text>
          <Text>{userInfo.points - product.pointsPrice}积分</Text>
        </View>
      </View>
      
      {/* 收货信息 */}
      <View className="delivery-section">
        <Text className="section-title">收货信息</Text>
        <AddressSelector 
          selectedAddress={selectedAddress}
          onAddressChange={setSelectedAddress}
        />
      </View>
      
      {/* 兑换按钮 */}
      <View className="action-section">
        <Button 
          className="confirm-btn"
          loading={exchanging}
          onPress={handleConfirmExchange}
        >
          确认兑换
        </Button>
      </View>
    </View>
  )
}
```

---

## 🔗 无缝对接技术实现

### 1. 统一状态管理

#### 全局状态设计
```typescript
// 全局用户状态
interface GlobalUserState {
  userInfo: {
    id: string
    nickname: string
    avatar: string
    phone: string
  }
  
  pointsInfo: {
    totalPoints: number
    availablePoints: number
    usedPoints: number
    expiringPoints: number
    lastUpdated: Date
  }
  
  mallState: {
    cartItems: CartItem[]
    favoriteProducts: string[]
    browsingHistory: BrowsingRecord[]
    recommendations: Product[]
  }
  
  paymentState: {
    currentOrder?: PaymentOrder
    lastPaymentSuccess?: PaymentResult
    pendingPointsAward?: number
  }
}

// 状态更新方法
const useUserState = () => {
  const [state, setState] = useState<GlobalUserState>(initialState)
  
  const updatePointsAfterPayment = (pointsAwarded: number) => {
    setState(prev => ({
      ...prev,
      pointsInfo: {
        ...prev.pointsInfo,
        totalPoints: prev.pointsInfo.totalPoints + pointsAwarded,
        availablePoints: prev.pointsInfo.availablePoints + pointsAwarded,
        lastUpdated: new Date()
      }
    }))
  }
  
  const updatePointsAfterExchange = (pointsUsed: number) => {
    setState(prev => ({
      ...prev,
      pointsInfo: {
        ...prev.pointsInfo,
        availablePoints: prev.pointsInfo.availablePoints - pointsUsed,
        usedPoints: prev.pointsInfo.usedPoints + pointsUsed,
        lastUpdated: new Date()
      }
    }))
  }
  
  return { state, updatePointsAfterPayment, updatePointsAfterExchange }
}
```

### 2. 智能导航系统

#### 上下文感知导航
```typescript
// 导航上下文管理
interface NavigationContext {
  source: 'payment_success' | 'payment_page' | 'home' | 'manual'
  userIntent: 'browse' | 'exchange' | 'earn_more'
  availablePoints: number
  recentActivity: ActivityRecord[]
}

const SmartNavigator = {
  // 从支付成功页面进入商城
  fromPaymentSuccess: (context: NavigationContext) => {
    return {
      route: '/pages/points-mall/index',
      params: {
        source: 'payment_success',
        highlight: 'affordable_products', // 突出显示可兑换商品
        showWelcome: true,
        recommendationType: 'post_payment'
      }
    }
  },
  
  // 从支付页面预览进入商城
  fromPaymentPreview: (context: NavigationContext) => {
    return {
      route: '/pages/points-mall/index',
      params: {
        source: 'payment_preview',
        highlight: 'aspirational_products', // 突出显示激励商品
        showComparison: true,
        expectedPoints: context.availablePoints
      }
    }
  },
  
  // 积分不足时的导航
  fromInsufficientPoints: (shortage: number) => {
    return {
      route: '/pages/earn-points/index',
      params: {
        target: shortage,
        returnUrl: '/pages/points-mall/index',
        showProgress: true
      }
    }
  }
}
```

### 3. 实时数据同步

#### WebSocket实时更新
```typescript
// 实时积分同步
class PointsWebSocketManager {
  private ws: WebSocket | null = null
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  
  connect(userId: string) {
    this.ws = new WebSocket(`wss://api.example.com/points/ws?userId=${userId}`)
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data)
      
      switch (data.type) {
        case 'points_awarded':
          this.handlePointsAwarded(data.payload)
          break
        case 'points_used':
          this.handlePointsUsed(data.payload)
          break
        case 'points_expired':
          this.handlePointsExpired(data.payload)
          break
      }
    }
    
    this.ws.onclose = () => {
      this.handleReconnect()
    }
  }
  
  private handlePointsAwarded(payload: PointsAwardPayload) {
    // 更新全局状态
    userStore.updatePoints(payload.newTotal)
    
    // 显示积分到账通知
    showPointsNotification({
      type: 'awarded',
      amount: payload.amount,
      source: payload.source
    })
    
    // 如果用户在商城页面，刷新推荐
    if (getCurrentRoute() === '/pages/points-mall/index') {
      refreshMallRecommendations()
    }
  }
}
```

---

## 🎨 视觉一致性设计

### 1. 统一设计语言

#### 积分相关视觉规范
```css
/* 积分主题色彩系统 */
:root {
  --points-gold: #FFD700;           /* 主色 - 金币色 */
  --points-orange: #FF6B35;         /* 辅助色 - 活力橙 */
  --points-bg-light: #FFF9E6;       /* 浅色背景 */
  --points-bg-gradient: linear-gradient(135deg, #FFD700 0%, #FF6B35 100%);
  
  /* 积分状态色 */
  --points-sufficient: #07C160;     /* 积分充足 */
  --points-insufficient: #FF3B30;   /* 积分不足 */
  --points-expiring: #FF9500;       /* 即将过期 */
}

/* 积分数字显示规范 */
.points-number {
  font-family: 'PingFang SC', 'Helvetica Neue', sans-serif;
  font-weight: 600;
  color: var(--points-gold);
  text-shadow: 0 1px 2px rgba(255, 215, 0, 0.3);
}

.points-large { font-size: 32px; }    /* 重要场景 */
.points-medium { font-size: 24px; }   /* 一般场景 */
.points-small { font-size: 16px; }    /* 次要场景 */

/* 积分图标规范 */
.points-icon {
  width: 20px;
  height: 20px;
  background: var(--points-gold);
  border-radius: 50%;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.points-icon::before {
  content: '积';
  font-size: 12px;
  color: white;
  font-weight: bold;
}
```

### 2. 动画连贯性

#### 积分流动动画
```css
/* 积分获得动画 */
@keyframes pointsFlow {
  0% {
    transform: translateY(0) scale(1);
    opacity: 1;
  }
  50% {
    transform: translateY(-20px) scale(1.2);
    opacity: 0.8;
  }
  100% {
    transform: translateY(-40px) scale(0.8);
    opacity: 0;
  }
}

.points-flow-animation {
  animation: pointsFlow 1.5s ease-out forwards;
}

/* 积分数字跳动 */
@keyframes pointsCount {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.points-count-up {
  animation: pointsCount 0.6s ease-out;
}

/* 商城入口呼吸动画 */
@keyframes mallPulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(255, 107, 53, 0.4);
  }
  50% { 
    transform: scale(1.05);
    box-shadow: 0 0 0 8px rgba(255, 107, 53, 0);
  }
}

.mall-entrance-pulse {
  animation: mallPulse 2s infinite;
}
```

---

## 📊 数据驱动优化

### 1. 关键指标监控

#### 对接效果指标
```typescript
const IntegrationMetrics = {
  // 支付页面指标
  paymentPage: {
    mallPreviewViewRate: '商城预告区查看率',
    productCardClickRate: '推荐商品点击率',
    mallEntranceClickRate: '商城入口点击率'
  },
  
  // 支付成功页指标
  paymentSuccess: {
    mallRedirectRate: '支付成功后进入商城率',
    immediateExchangeRate: '立即兑换率',
    productDetailViewRate: '商品详情查看率'
  },
  
  // 商城页面指标
  mallPage: {
    fromPaymentConversionRate: '从支付页面进入的转化率',
    averageSessionDuration: '平均停留时长',
    exchangeCompletionRate: '兑换完成率',
    returnVisitRate: '重复访问率'
  },
  
  // 整体生态指标
  ecosystem: {
    pointsCirculationRate: '积分流通率',
    userLifetimeValue: '用户生命周期价值',
    crossModuleEngagement: '跨模块参与度'
  }
}
```

### 2. A/B测试方案

#### 关键测试维度
```typescript
const ABTestScenarios = {
  // 测试1：支付页面商城预告位置
  mallPreviewPosition: {
    versions: {
      A: '积分奖励区下方',
      B: '支付按钮上方',
      C: '浮动悬浮窗'
    },
    metrics: ['点击率', '支付转化率', '商城访问率']
  },
  
  // 测试2：推荐商品数量
  recommendedProductsCount: {
    versions: {
      A: '3个商品',
      B: '5个商品', 
      C: '8个商品'
    },
    metrics: ['加载时间', '点击率', '用户停留时间']
  },
  
  // 测试3：积分价值表达方式
  pointsValueExpression: {
    versions: {
      A: '仅显示积分数量',
      B: '积分+等价金额',
      C: '积分+可兑换商品'
    },
    metrics: ['价值感知度', '兑换意愿', '满意度']
  }
}
```

---

## 🎯 个性化推荐系统

### 1. 用户画像构建

#### 多维度用户标签
```typescript
interface UserProfile {
  // 基础信息
  demographics: {
    age: number
    gender: 'male' | 'female' | 'unknown'
    location: string
    income_level: 'low' | 'medium' | 'high'
  }
  
  // 消费行为
  consumption: {
    frequency: number           // 消费频次
    averageAmount: number       // 平均消费金额
    preferredMerchants: string[] // 偏好商户
    consumptionTime: string[]   // 消费时间偏好
  }
  
  // 积分行为
  points: {
    accumulationRate: number    // 积分累积速度
    exchangeFrequency: number   // 兑换频次
    preferredCategories: string[] // 偏好兑换品类
    pricesensitivity: 'low' | 'medium' | 'high' // 价格敏感度
  }
  
  // 兴趣偏好
  interests: {
    productCategories: string[] // 商品品类偏好
    brandPreference: string[]   // 品牌偏好
    seasonalTrends: any        // 季节性趋势
  }
}
```

### 2. 智能推荐算法

#### 混合推荐策略
```typescript
class SmartRecommendationEngine {
  // 协同过滤推荐
  collaborativeFiltering(userId: string): Product[] {
    // 找到相似用户
    const similarUsers = this.findSimilarUsers(userId)
    
    // 获取相似用户的兑换偏好
    const preferences = this.getUserPreferences(similarUsers)
    
    // 返回推荐商品
    return this.rankProducts(preferences, userId)
  }
  
  // 内容基础推荐
  contentBasedFiltering(userProfile: UserProfile): Product[] {
    return products.filter(product => 
      userProfile.interests.productCategories.includes(product.category) &&
      product.pointsPrice <= userProfile.points.averageExchange * 1.2
    )
  }
  
  // 热度推荐
  popularityBased(): Product[] {
    return products
      .sort((a, b) => b.exchangeCount - a.exchangeCount)
      .slice(0, 10)
  }
  
  // 实时推荐
  realTimeRecommendation(context: RecommendationContext): Product[] {
    const { userPoints, recentActivity, currentTime } = context
    
    // 基于实时上下文的推荐
    return this.hybridRecommendation({
      collaborative: this.collaborativeFiltering(context.userId),
      contentBased: this.contentBasedFiltering(context.userProfile),
      popularity: this.popularityBased(),
      contextual: this.getContextualProducts(context)
    })
  }
}
```

---

## 🔄 用户留存机制

### 1. 积分激励循环

#### 完整激励闭环设计
```typescript
const RetentionLoop = {
  // 阶段1：首次体验
  firstExperience: {
    trigger: '首次支付成功',
    reward: '新手专享积分奖励',
    guide: '引导进入商城体验兑换',
    followUp: '24小时后推送商城新品消息'
  },
  
  // 阶段2：习惯养成
  habitBuilding: {
    trigger: '连续3次支付',
    reward: '连续消费奖励积分',
    guide: '展示积分累积进度',
    followUp: '推荐高价值兑换商品'
  },
  
  // 阶段3：深度参与
  deepEngagement: {
    trigger: '首次在商城兑换',
    reward: '兑换返还部分积分',
    guide: '介绍会员等级系统',
    followUp: '定期推送专属优惠'
  },
  
  // 阶段4：忠诚维护
  loyaltyMaintenance: {
    trigger: '成为高级会员',
    reward: '专属积分倍率',
    guide: 'VIP商品推荐',
    followUp: '生日特权和节日福利'
  }
}
```

### 2. 社交化元素

#### 积分分享和互动
```jsx
// 分享成就组件
const AchievementShare = ({ achievement }) => {
  const shareAchievement = () => {
    const shareData = {
      title: `我在积分商城获得了${achievement.name}！`,
      desc: `通过消费积累积分，兑换心仪商品，你也来试试吧`,
      path: '/pages/points-mall/index?invite=' + currentUser.id,
      imageUrl: achievement.shareImage
    }
    
    wx.shareAppMessage(shareData)
  }
  
  return (
    <View className="achievement-card">
      <Image src={achievement.badge} className="achievement-badge" />
      <Text className="achievement-name">{achievement.name}</Text>
      <Text className="achievement-desc">{achievement.description}</Text>
      <Button className="share-btn" onPress={shareAchievement}>
        分享成就
      </Button>
    </View>
  )
}

// 邀请奖励机制
const InviteReward = {
  inviter: {
    newUserRegister: '邀请新用户注册获得50积分',
    newUserFirstPay: '被邀请用户首次支付获得100积分',
    newUserFirstExchange: '被邀请用户首次兑换获得50积分'
  },
  
  invitee: {
    registerBonus: '注册即获得20积分',
    firstPayBonus: '首次支付额外获得50积分',
    firstExchangeDiscount: '首次兑换享受8折优惠'
  }
}
```

---

## ✅ 实施计划和验收标准

### 1. 分阶段实施计划

#### Phase 1：基础对接（Week 1-2）
- [ ] 支付页面添加商城预告区
- [ ] 支付成功页面集成商城推荐
- [ ] 基础商城页面搭建
- [ ] 统一状态管理实现

#### Phase 2：智能推荐（Week 3-4）
- [ ] 用户画像系统开发
- [ ] 推荐算法实现
- [ ] 个性化商品展示
- [ ] 实时数据同步

#### Phase 3：体验优化（Week 5-6）
- [ ] 视觉一致性完善
- [ ] 动画效果优化
- [ ] 性能优化
- [ ] A/B测试实施

#### Phase 4：增长机制（Week 7-8）
- [ ] 社交化功能开发
- [ ] 激励循环完善
- [ ] 数据分析系统
- [ ] 运营工具开发

### 2. 验收标准

#### 功能验收
- [ ] 支付页面商城预告正常显示
- [ ] 支付成功后商城跳转流畅
- [ ] 积分余额实时同步准确
- [ ] 商品推荐算法生效
- [ ] 兑换流程完整可用

#### 体验验收
- [ ] 页面加载时间≤3秒
- [ ] 跳转动画流畅自然
- [ ] 视觉风格统一一致
- [ ] 操作流程简单直观
- [ ] 错误处理友好完善

#### 业务验收
- [ ] 支付到商城转化率≥30%
- [ ] 商城页面停留时间≥60秒
- [ ] 积分兑换完成率≥80%
- [ ] 用户满意度≥4.5分
- [ ] 重复使用率≥40%

---

**文档状态**：待产品评审  
**下一步行动**：原型设计和技术方案细化  
**责任人**：产品经理  
**评审时间**：待定
